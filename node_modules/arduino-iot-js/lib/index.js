'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _pahoClient = require('paho-client');

var _pahoClient2 = _interopRequireDefault(_pahoClient);

var _cborJs = require('@arduino/cbor-js');

var _cborJs2 = _interopRequireDefault(_cborJs);

var _ArduinoCloudError = require('./ArduinoCloudError');

var _ArduinoCloudError2 = _interopRequireDefault(_ArduinoCloudError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } /*
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * Copyright 2018 ARDUINO SA (http://www.arduino.cc/)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * This file is part of arduino-iot-js.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * Copyright (c) 2018
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * Authors: Fabrizio Mirabito
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * This software is released under:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * The GNU General Public License, which covers the main part of
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * arduino-iot-js
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * The terms of this license can be found at:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * https://www.gnu.org/licenses/gpl-3.0.en.html
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * You can be released from the requirements of the above licenses by purchasing
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * a commercial license. Buying such a license is mandatory if you want to modify or
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * otherwise use the software for commercial activities involving the Arduino
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * software without disclosing the source code of your own applications. To purchase
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           * a commercial license, send an email to license@arduino.cc.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           */

/*
     SenML labels
     https://tools.ietf.org/html/draft-ietf-core-senml-16#section-4.3

     +---------------+-------+------------+------------+------------+
     |          Name | Label | CBOR Label | JSON Type  | XML Type   |
     +---------------+-------+------------+------------+------------+
     |     Base Name | bn    |         -2 | String     | string     |
     |     Base Time | bt    |         -3 | Number     | double     |
     |     Base Unit | bu    |         -4 | String     | string     |
     |    Base Value | bv    |         -5 | Number     | double     |
     |      Base Sum | bs    |         -6 | Number     | double     |
     |       Version | bver  |         -1 | Number     | int        |
     |          Name | n     |          0 | String     | string     |
     |          Unit | u     |          1 | String     | string     |
     |         Value | v     |          2 | Number     | double     |
     |  String Value | vs    |          3 | String     | string     |
     | Boolean Value | vb    |          4 | Boolean    | boolean    |
     |    Data Value | vd    |          8 | String (*) | string (*) |
     |     Value Sum | s     |          5 | Number     | double     |
     |          Time | t     |          6 | Number     | double     |
     |   Update Time | ut    |          7 | Number     | double     |
     +---------------+-------+------------+------------+------------+
*/

var connection = null;
var connectionOptions = null;
var subscribedTopics = {};
var propertyCallback = {};
var arduinoCloudPort = 8443;
var arduinoCloudHost = 'wss.iot.arduino.cc';
var arduinoAuthURL = 'https://api2.arduino.cc';

var getUserId = function getUserId(apiUrl, token) {
  return fetch(apiUrl, {
    method: 'get',
    headers: new Headers({
      Authorization: 'Bearer ' + token,
      'Content-Type': 'application/json'
    })
  }).then(function (res) {
    return res.json();
  });
};

// Connect establishes a connection with mqtt, using token as the password, and returns a promise
// of a Symbol identifying the mqtt client
var connect = function connect(options) {
  return new Promise(function (resolve, reject) {
    var ssl = false;
    if (options.ssl !== false) {
      ssl = true;
    }
    var opts = {
      host: options.host || arduinoCloudHost,
      port: options.port || arduinoCloudPort,
      apiUrl: options.apiUrl || arduinoAuthURL,
      ssl: ssl,
      token: options.token,
      onDisconnect: options.onDisconnect,
      onTrace: options.onTrace,
      onConnected: options.onConnected,
      useCloudProtocolV2: options.useCloudProtocolV2 || false
    };

    connectionOptions = opts;

    if (connection) {
      return reject(new Error('connection failed: connection already open'));
    }

    if (!opts.host) {
      return reject(new Error('connection failed: you need to provide a valid host (broker)'));
    }

    if (!opts.token) {
      return reject(new Error('connection failed: you need to provide a valid token'));
    }

    if (!opts.apiUrl) {
      return reject(new Error('no apiUrl parameter is provided'));
    }

    return getUserId(opts.apiUrl + '/users/v1/users/byID/me', options.token).then(function (res) {
      var clientID = res.id + ':' + new Date().getTime();
      var client = new _pahoClient2.default.Client(opts.host, opts.port, clientID);
      client.topics = {};
      client.properties = {};

      client.onMessageArrived = function (msg) {
        if (msg.topic.indexOf('/s/o') > -1) {
          client.topics[msg.topic].forEach(function (cb) {
            cb(msg.payloadString);
          });
        } else {
          var buf = new ArrayBuffer(msg.payloadBytes.length);
          var bufView = new Uint8Array(buf);
          for (var i = 0, strLen = msg.payloadBytes.length; i < strLen; i += 1) {
            bufView[i] = msg.payloadBytes[i];
          }

          var propertyValue = _cborJs2.default.decode(buf);
          var propertyNameId = 0;
          var attributeNameId = 1;

          var valueToSend = {};
          var propertyNameKeyPrevious = '';
          var propertyNameKey = '';
          propertyValue.forEach(function (p) {
            // Support cbor labels
            propertyNameKey = p.n !== undefined ? p.n : p['0'];
            var propertyNameKeySplit = propertyNameKey.split(':');

            var valueKey = p.v !== undefined ? 'v' : '2';
            var valueStringKey = p.vs !== undefined ? 'vs' : '3';
            var valueBooleanKey = p.vb !== undefined ? 'vb' : '4';
            var value = null;
            propertyNameKey = propertyNameKeySplit[propertyNameId];
            if (propertyCallback[msg.topic][propertyNameKey]) {
              if (!(p[valueKey] === undefined)) {
                value = p[valueKey];
              } else if (!(p[valueStringKey] === undefined)) {
                value = p[valueStringKey];
              } else if (!(p[valueBooleanKey] === undefined)) {
                value = p[valueBooleanKey];
              }
            }
            if (propertyNameKeyPrevious === '') {
              propertyNameKeyPrevious = propertyNameKeySplit[propertyNameId];
            }
            if (propertyNameKeyPrevious !== propertyNameKey) {
              if (propertyCallback[msg.topic][propertyNameKeyPrevious]) {
                propertyCallback[msg.topic][propertyNameKeyPrevious](valueToSend);
              }
              propertyNameKeyPrevious = propertyNameKey;
              valueToSend = {};
            }
            if (propertyNameKeySplit.length === 1 && value !== null) {
              valueToSend = value;
            } else {
              var attributeName = propertyNameKeySplit[attributeNameId];
              valueToSend[attributeName] = value;
            }
          });
          if (valueToSend !== {} && propertyCallback[msg.topic][propertyNameKey]) {
            propertyCallback[msg.topic][propertyNameKey](valueToSend);
          }
        }
      };

      client.onConnected = function (reconnect) {
        var reconnectPromises = [];

        if (reconnect === true) {
          // This is a re-connection: re-subscribe to all topics subscribed before the
          // connection loss
          Object.values(subscribedTopics).forEach(function (subscribeParams) {
            reconnectPromises.push(function () {
              return subscribe(subscribeParams.topic, subscribeParams.cb);
            });
          });
        }

        return Promise.all(reconnectPromises).then(function () {
          if (typeof opts.onConnected === 'function') {
            opts.onConnected(reconnect);
          }
        });
      };

      if (typeof onDisconnect === 'function') {
        client.onConnectionLost = opts.onDisconnect;
      }

      var connectionOpts = {
        useSSL: opts.ssl,
        timeout: 30,
        mqttVersion: 4,
        userName: res.id,
        // password: token,
        mqttVersionExplicit: true,
        // If reconnect is set to true, in the event that the connection is lost, the client will
        // attempt to reconnect to the server. It will initially wait 1 second before it attempts
        // to reconnect, for every failed reconnect attempt, the delay will double until it is at
        // 2 minutes at which point the delay will stay at 2 minutes.
        reconnect: true,
        keepAliveInterval: 30,
        onSuccess: function onSuccess() {
          connection = client;
          return resolve();
        },
        onFailure: function onFailure(_ref) {
          var errorCode = _ref.errorCode,
              errorMessage = _ref.errorMessage;
          return reject(new _ArduinoCloudError2.default(errorCode, errorMessage));
        }
      };

      connectionOpts.password = opts.token;

      if (typeof opts.onTrace === 'function') {
        client.trace = function (log) {
          opts.onTrace(log);
        };
      }

      client.connect(connectionOpts);
    }, reject);
  });
};

var disconnect = function disconnect() {
  return new Promise(function (resolve, reject) {
    if (!connection) {
      return reject(new Error('disconnection failed: connection closed'));
    }

    try {
      connection.disconnect();
    } catch (error) {
      return reject(error);
    }

    // Remove the connection
    connection = null;

    // Remove property callbacks to allow resubscribing in a later connect()
    Object.keys(propertyCallback).forEach(function (topic) {
      if (propertyCallback[topic]) {
        delete propertyCallback[topic];
      }
    });

    // Clean up subscribed topics - a new connection might not need the same topics
    Object.keys(subscribedTopics).forEach(function (topic) {
      delete subscribedTopics[topic];
    });

    return resolve();
  });
};

var updateToken = function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(token) {
    var reconnectOptions;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!true) {
              _context.next = 18;
              break;
            }

            _context.prev = 1;

            if (connection) {
              // Disconnect to the connection that is using the old token
              connection.disconnect();

              // Remove the connection
              connection = null;
            }

            // Reconnect using the new token
            reconnectOptions = Object.assign({}, connectionOptions, { token: token });
            _context.next = 6;
            return connect(reconnectOptions);

          case 6:

            // Re-subscribe to all topics subscribed before the reconnection
            Object.values(subscribedTopics).forEach(function (subscribeParams) {
              subscribe(subscribeParams.topic, subscribeParams.cb);
            });

            if (typeof connectionOptions.onConnected === 'function') {
              // Call the connection callback (with the reconnection param set to true)
              connectionOptions.onConnected(true);
            }

            // Exit the infinite loop
            return _context.abrupt('return');

          case 11:
            _context.prev = 11;
            _context.t0 = _context['catch'](1);

            // Expose paho-mqtt errors
            // eslint-disable-next-line no-console
            console.error(_context.t0);

            // Something went wrong during the reconnection - retry in 5 secs.
            _context.next = 16;
            return new Promise(function (resolve) {
              setTimeout(resolve, 5000);
            });

          case 16:
            _context.next = 0;
            break;

          case 18:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this, [[1, 11]]);
  }));

  function updateToken(_x) {
    return _ref2.apply(this, arguments);
  }

  return updateToken;
}();

var subscribe = function subscribe(topic, cb) {
  return new Promise(function (resolve, reject) {
    if (!connection) {
      return reject(new Error('subscription failed: connection closed'));
    }

    return connection.subscribe(topic, {
      onSuccess: function onSuccess() {
        if (!connection.topics[topic]) {
          connection.topics[topic] = [];
        }
        connection.topics[topic].push(cb);
        return resolve(topic);
      },
      onFailure: function onFailure(error) {
        return reject(new Error('subscription failed: ' + error.errorMessage));
      }
    });
  });
};

var unsubscribe = function unsubscribe(topic) {
  return new Promise(function (resolve, reject) {
    if (!connection) {
      return reject(new Error('disconnection failed: connection closed'));
    }

    return connection.unsubscribe(topic, {
      onSuccess: function onSuccess() {
        return resolve(topic);
      },
      onFailure: function onFailure() {
        return reject();
      }
    });
  });
};

var arrayBufferToBase64 = function arrayBufferToBase64(buffer) {
  var binary = '';
  var bytes = new Uint8Array(buffer);
  var len = bytes.byteLength;
  for (var i = 0; i < len; i += 1) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
};

var sendMessage = function sendMessage(topic, message) {
  return new Promise(function (resolve, reject) {
    if (!connection) {
      return reject(new Error('disconnection failed: connection closed'));
    }

    connection.publish(topic, message, 1, false);
    return resolve();
  });
};

var openCloudMonitor = function openCloudMonitor(deviceId, cb) {
  var cloudMonitorOutputTopic = '/a/d/' + deviceId + '/s/o';
  return subscribe(cloudMonitorOutputTopic, cb);
};

var writeCloudMonitor = function writeCloudMonitor(deviceId, message) {
  var cloudMonitorInputTopic = '/a/d/' + deviceId + '/s/i';
  return sendMessage(cloudMonitorInputTopic, message);
};

var closeCloudMonitor = function closeCloudMonitor(deviceId) {
  var cloudMonitorOutputTopic = '/a/d/' + deviceId + '/s/o';
  return unsubscribe(cloudMonitorOutputTopic);
};

var toCloudProtocolV2 = function toCloudProtocolV2(cborValue) {
  var cloudV2CBORValue = {};
  var cborLabel = null;

  Object.keys(cborValue).forEach(function (label) {
    switch (label) {
      case 'bn':
        cborLabel = -2;
        break;
      case 'bt':
        cborLabel = -3;
        break;
      case 'bu':
        cborLabel = -4;
        break;
      case 'bv':
        cborLabel = -5;
        break;
      case 'bs':
        cborLabel = -6;
        break;
      case 'bver':
        cborLabel = -1;
        break;
      case 'n':
        cborLabel = 0;
        break;
      case 'u':
        cborLabel = 1;
        break;
      case 'v':
        cborLabel = 2;
        break;
      case 'vs':
        cborLabel = 3;
        break;
      case 'vb':
        cborLabel = 4;
        break;
      case 'vd':
        cborLabel = 8;
        break;
      case 's':
        cborLabel = 5;
        break;
      case 't':
        cborLabel = 6;
        break;
      case 'ut':
        cborLabel = 7;
        break;
      default:
        cborLabel = label;
    }

    cloudV2CBORValue[cborLabel] = cborValue[label];
  });

  return cloudV2CBORValue;
};

var sendProperty = function sendProperty(thingId, name, value, timestamp) {
  var propertyInputTopic = '/a/t/' + thingId + '/e/i';

  if (timestamp && !Number.isInteger(timestamp)) {
    throw new Error('Timestamp must be Integer');
  }

  if (name === undefined || typeof name !== 'string') {
    throw new Error('Name must be a valid string');
  }

  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
    var objectKeys = Object.keys(value);
    var cborValues = objectKeys.map(function (key, i) {
      var cborValue = {
        n: name + ':' + key
      };

      if (i === 0) {
        cborValue.bt = timestamp || new Date().getTime();
      }

      switch (_typeof(value[key])) {
        case 'string':
          cborValue.vs = value[key];
          break;
        case 'number':
          cborValue.v = value[key];
          break;
        case 'boolean':
          cborValue.vb = value[key];
          break;
        default:
          break;
      }

      return cborValue;
    }).map(function (cborValue) {
      if (connectionOptions.useCloudProtocolV2) {
        return toCloudProtocolV2(cborValue);
      }

      return cborValue;
    });

    return sendMessage(propertyInputTopic, _cborJs2.default.encode(cborValues, true));
  }

  var cborValue = {
    bt: timestamp || new Date().getTime(),
    n: name
  };

  switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
    case 'string':
      cborValue.vs = value;
      break;
    case 'number':
      cborValue.v = value;
      break;
    case 'boolean':
      cborValue.vb = value;
      break;
    default:
      break;
  }

  if (connectionOptions.useCloudProtocolV2) {
    cborValue = toCloudProtocolV2(cborValue);
  }

  return sendMessage(propertyInputTopic, _cborJs2.default.encode([cborValue], true));
};

var getSenml = function getSenml(deviceId, name, value, timestamp) {
  if (timestamp && !Number.isInteger(timestamp)) {
    throw new Error('Timestamp must be Integer');
  }

  if (name === undefined || typeof name !== 'string') {
    throw new Error('Name must be a valid string');
  }

  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
    var objectKeys = Object.keys(value);
    var senMls = objectKeys.map(function (key, i) {
      var senMl = {
        n: name + ':' + key
      };

      if (i === 0) {
        senMl.bt = timestamp || new Date().getTime();

        if (deviceId) {
          senMl.bn = 'urn:uuid:' + deviceId;
        }
      }

      switch (_typeof(value[key])) {
        case 'string':
          senMl.vs = value[key];
          break;
        case 'number':
          senMl.v = value[key];
          break;
        case 'boolean':
          senMl.vb = value[key];
          break;
        default:
          break;
      }

      return senMl;
    }).map(function (senMl) {
      if (connectionOptions.useCloudProtocolV2) {
        return toCloudProtocolV2(senMl);
      }

      return senMl;
    });

    return senMls;
  }

  var senMl = {
    bt: timestamp || new Date().getTime(),
    n: name
  };

  if (deviceId) {
    senMl.bn = 'urn:uuid:' + deviceId;
  }

  switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {
    case 'string':
      senMl.vs = value;
      break;
    case 'number':
      senMl.v = value;
      break;
    case 'boolean':
      senMl.vb = value;
      break;
    default:
      break;
  }

  if (connectionOptions.useCloudProtocolV2) {
    return toCloudProtocolV2(senMl);
  }

  return senMl;
};

var getCborValue = function getCborValue(senMl) {
  var cborEncoded = _cborJs2.default.encode(senMl);
  return arrayBufferToBase64(cborEncoded);
};

var sendPropertyAsDevice = function sendPropertyAsDevice(deviceId, thingId, name, value, timestamp) {
  var propertyInputTopic = '/a/t/' + thingId + '/e/o';

  if (timestamp && !Number.isInteger(timestamp)) {
    throw new Error('Timestamp must be Integer');
  }

  if (name === undefined || typeof name !== 'string') {
    throw new Error('Name must be a valid string');
  }

  var senMlValue = getSenml(deviceId, name, value, timestamp);
  return sendMessage(propertyInputTopic, _cborJs2.default.encode([senMlValue]));
};

var onPropertyValue = function onPropertyValue(thingId, name, cb) {
  if (!name) {
    throw new Error('Invalid property name');
  }
  if (typeof cb !== 'function') {
    throw new Error('Invalid callback');
  }
  var propOutputTopic = '/a/t/' + thingId + '/e/o';

  subscribedTopics[thingId] = {
    topic: propOutputTopic,
    cb: cb
  };

  if (!propertyCallback[propOutputTopic]) {
    propertyCallback[propOutputTopic] = {};
    propertyCallback[propOutputTopic][name] = cb;
    return subscribe(propOutputTopic, cb);
  }

  if (propertyCallback[propOutputTopic] && !propertyCallback[propOutputTopic][name]) {
    propertyCallback[propOutputTopic][name] = cb;
  }
  return Promise.resolve(propOutputTopic);
};

var removePropertyValueCallback = function removePropertyValueCallback(thingId, name) {
  if (!name) {
    throw new Error('Invalid property name');
  }
  var propOutputTopic = '/a/t/' + thingId + '/e/o';
  delete propertyCallback[propOutputTopic][name];
  return Promise.resolve(propOutputTopic);
};

exports.default = {
  connect: connect,
  disconnect: disconnect,
  updateToken: updateToken,
  subscribe: subscribe,
  unsubscribe: unsubscribe,
  sendMessage: sendMessage,
  openCloudMonitor: openCloudMonitor,
  writeCloudMonitor: writeCloudMonitor,
  closeCloudMonitor: closeCloudMonitor,
  sendProperty: sendProperty,
  sendPropertyAsDevice: sendPropertyAsDevice,
  onPropertyValue: onPropertyValue,
  removePropertyValueCallback: removePropertyValueCallback,
  getCborValue: getCborValue,
  getSenml: getSenml,
  ArduinoCloudError: _ArduinoCloudError2.default
};